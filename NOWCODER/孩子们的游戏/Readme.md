## 剑指offer——孩子们的游戏
### 【题目描述】
每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)

如果没有小朋友，请返回-1

### 【解题思路】
简化的约瑟夫环问题。

思路一：使用数组模拟游戏
采用标记数组的方法，用一个数组标记所有小朋友的状态。每次数了m个小朋友以后就标记一个小朋友。这样循环知道标记了n个小朋友。返回最后一个标记的小朋友的序号。
这种方法每次需要访问数组中每个元素，代价较大。

思路二：使用List模拟链表
使用List存每个小朋友的序号。直接根据取模运算算出来每次应该去除掉第几个元素，直接移除。最终剩下的一个元素就是答案。

思路三：找规律
这个规律是看了别人的分析发现的。
我们注意到原问题仅仅是要求出最后的胜利者的序号，而不是要读者模拟整个过程。因此如果要追求效率，就要打破常规，实施一点数学策略。

为了讨论方便，先把问题稍微改变一下，并不影响原意：
问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。

我们知道第一个人(编号一定是**(m - 1)% n**-- 不理解的可以自己试一下，反正一定是取余操作) 出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k = (m - 1)%n的人开始）:

** k+1 k+2 … n-2, n-1, 0, 1, 2, … k-2, k - 1**

并且从k开始报0。
下面把(k+1 k+2 … n-2, n-1, 0, 1, 2, … k-2, k - 1)转换为(0~n-2)的形式，即：

k + 1 --> 0
k + 2 --> 1
k + 3 --> 2
…
…
k - 2 --> n-3
k - 1 --> n-2

变换后就完完全全成为了(n-1)个人报数的子问题。

假如我们知道这个子问题(n - 1个人)的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去刚好就是n个人情况的解吗！！
变回去的公式很简单，相信大家都可以推出来：x’=(x + k + 1)%n

如何知道(n-1)个人报数的问题的解？对，只要知道(n-2)个人的解就行了。(n-2)个人的解呢？当然是先求(n-3)的情况 ---- 这显然就是一个倒推问题！好了，思路出来了，下面写递推公式：

令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]

递推公式
f[1]=0;
f[i]=(f[i-1]+ k + 1)%n = (f[i-1]+ (m - 1)%n + 1)%n = (f[i-1]+ m - 1 + 1 + n)%n = (f[i-1]+ m)%n; (i>1)

有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。

原文链接：https://blog.csdn.net/qq_37886086/article/details/89705044

### 【代码实现】
思路一：

```java
public int LastRemaining_Solution(int n, int m)
    {
        if (n==0)
            return -1;
        boolean[] visited = new boolean[n];
        int count = -1;
        int sum = 0;
        int index = -1;
        while (true)
        {
            index = index+1 == n ? 0: index+1; //判断是继续往下走还是循环回到数组头部
            if (!visited[index])
                count++;
            if (count == m-1)
            {
                visited[index] = true;
                if (++sum == n)
                {
                    return index;
                }
                count = -1;
            }
        }
    }
```


思路二：

```java
public int LastRemaining_Solution_v2(int n, int m)
    {
        if (n==0)
            return -1;
        List<Integer> students = new LinkedList<>();
        for (int i=0; i<n; i++)
        {
            students.add(i);
        }
        int index = 0;
        while (students.size()>1)
        {
            index = (index + m - 1) % students.size();
            students.remove(index);
        }
        return students.get(0);
    }
```
