# 剑指offer——二维数组中的查找
## 【题目描述】
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

## 【代码思路】
一开始看到这个题目的时候，因为题目说每一行每一列都是有序递增的顺序排序的，第一反应就是想到折半查找。按照折半查找的思路，是从排序数组两边，一个最大一个最小元素，使用中间元素与target比较。可是在这个题目中，只是每一行有序，每一列有序。如果单使用某一列元素进行比较，锁定某一行，再在某一行中继续折半查找，这样的方法不可行。因为对某一列元素与target的比较，并不能使用元素值比target大或者小的标准，因为不同的行，target不一定比最后一列中的每一个元素都大或者小，这是说不定的。所以这样的方法不可行。

可行的方法：对于题目矩阵来说，矩阵右上角元素，其所在行左侧元素都比它小，其所在列下方元素都比它大。是一个转折的点。因此将target于矩阵右上角元素比较，若target小于右上角元素，则删除右上角元素所在列；若target大于右上角元素，则删除右上角元素所在行。若相等，则找到结果。按照此方法，直至找到相同元素或者矩阵范围为空，则停止。
同理矩阵左下角元素也可用于求解，其所在行右侧元素都比它大，其所在列上方元素都比它小。

## 【代码实现】

```
/**
 * @Author: makexin
 * @Date: 2019/9/10 10:17
 */
public class Solution {
    public boolean Find(int target, int [][] array)
    {
        int i = 0;
        int j = array[0].length - 1;
        while (i<array.length && j>=0)  //比较矩阵范围是否合理，这样可以避免范围不合理，取矩阵元素抛出异常的情况
        {
            if (target == array[i][j])
                break;
            if (target > array[i][j])
            {
                i++;
            }
            else
                j--;
        }

        if (i>=array.length || j<0)
            return false;
        else
            return true;

    }
}

```
