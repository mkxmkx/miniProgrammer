## java虚拟机——虚拟机字节码执行引擎
## 栈帧
**栈帧**是用于支持虚拟机进行方法调用和方法执行的数据结构。
每一个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。
栈帧包含：局部变量表、操作数栈、动态连接、方法返回地址和一些额外的信息。在编译时期，多数操作数栈已经完全确定并写入方法表的Code属性。因此一个镇站需要分配多少内存不会受到程序运行期变量数据的影响。

1、局部变量表
是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。

2、操作数栈
java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。

3、动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所述方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

## 方法调用
方法调用不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（**即调用哪一个方法**）。

**解析**：方法在程序真正运行之前就有一个可确定的调用版本，且在运行期是不可改变的。
**分派调用**：可能是静态的，也可能是动态的。
分派调用揭示多态性特征的一些最基本的特征。

1、**静态分派**
虚拟机（准确的说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。静态类型是编译器可知的。

所有依赖于静态类型来定位方法执行版本的分派动作成为静态分派。
**静态分派作用——方法重载**。

2、**动态分派**
**动态分派作用——多态性——重写（override）**
在运行期确定接收者的实际类型。

## 基于栈的字节码解释执行引擎
两种：基于栈的指令集、 基于寄存器的指令集
各有优缺点
基于栈的指令集：优点：可移植，代码相对更加紧凑，编译器实现更加简单，不需要考虑空间分配的问题，所需空间都在栈上操作。缺点：执行速度相对慢。因为栈实现在内存当中，频繁的栈访问也就意味着频繁的内存访问。内存始终是执行速度的瓶颈。
基于寄存器的指令集：优点：快一点。缺点：受到硬件的约束。寄存器由直接提供。 