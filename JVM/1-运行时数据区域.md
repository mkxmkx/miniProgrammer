相比于C、C++， 使用java开发的一个优点是：在虚拟机自动内存管理机制的帮助下，不用为每一个new操作写配对的delet/free代码，因此不容易出现内存泄漏和内存溢出的问题。而使用C、C++则需要负责每一个对象生命开始到终结。

将内存控制的权利交给java虚拟机，一旦出现内存泄漏和内存溢出方面的问题，就需要了解java虚拟机是怎样使用内存的。

## 运行时数据区域
java虚拟机在执行java程序的过程中会把所需管理的内存划分为若干个不同的数据区域。
![java虚拟机运行时数据区](https://img-blog.csdnimg.cn/20190909161231801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hX2tlX3hpbg==,size_16,color_FFFFFF,t_70)
java运行时数据区

## 1、程序计数器——（线程私有）
**程序计数器**是一块较小的内存空间，可以看作是**当前线程**所执行的字节码的行号指示器。字节码解释器工作室就是通过改变这个计数器的值来选择下一个需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都是依赖于程序计数器来完成的。

java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。
为了线程切换后能恢复到正确的执行位置，**每个线程都会有一个独立的程序计数器**，各线程之间计数器互不影响，独立存储。

**此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMenoryError情况的区域**。

## 2、java虚拟机栈——（线程私有）（重要）
java虚拟机栈也是线程私有的。
虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。因此每一个方法从调用到执行完成的过程，都对应一个栈帧在虚拟机栈中从入栈到出栈的过程。
局部变量表存放了编译期可知的各种基本数据类型和对象引用。局部变量表所需的内存空间在编译期间完成分配。
## 3、本地方法栈
java虚拟机栈为虚拟机执行java方法服务，本地方法栈为虚拟机使用到的Native方法服务。

## 4、java堆（重要）
java堆是java虚拟机所管理的内存中最大的一块。**Java堆是被所有线程共享的一块内存区域。**
**java堆的目的是：存放实例**。  java虚拟机规范中的描述：所有的对象实例以及数组都要在堆上分配。（现在已经不那么绝对了）。
**java堆是垃圾收集器管理的主要区域。**
java堆可以处于物理上不连续的内存空间，只要逻辑上是连续的即可。

## 5、方法区
**方法区是各个线程共享的内存区域**，用于存储一杯虚拟机加载的类信息、敞亮、静态变量、即时编译器编译后的代码等数据。
java虚拟机对方法区的限制非常宽松，除了不需要连续的内存，还**可以选择不实现垃圾收集**。（因此可能发生内存泄漏）

## 6、运行时常量池
class文件除了有类的版本、字段、方法、接口等描述信息，还有常量池（存放编译期生成的各种字面量和符号引用）。
运行时常量池除了保存class文件中描述的符号引用外，还会把翻译出的直接引用也存储在运行时常量池中。

运行时常量池有一个特征：动态性。即运行期间也可能产生新的常量放入池中。

## 7、直接内存
JDK1.4中新加入NIO（new Input/Output）类，引入了一种基于通道与缓冲区的I/O方式，使用native函数库直接分配堆外内存，然后通过存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。可以显著提高性能，避免在java堆和native堆中来回复制数据。