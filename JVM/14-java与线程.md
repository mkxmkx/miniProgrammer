## java内存模型

多任务处理在现代计算机操作系统中必须的原因：计算机的运行速度与他的存储和通信子系统速度的差距太大，大量的时间都花费在磁盘I/O、网络通信或数据库访问上。

让计算机并发的执行若干个计算任务，但是大多数的计算任务都不可能只靠处理器“计算”就能完成，处理器至少要与内存交互，如读取运算出具、存储运算结果，这个I/O操作是很难消除的。

通过加入一层**高速缓存（Cache）**来作为内存和处理器之间的缓冲：将运算需要的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存当中，这样处理器无需等待缓慢的内存读写了。

**缓存一致性**问题：
当多个处理器的运算任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致，这样同步回主内存是以谁的缓存数据为准？
缓存一致性问题通过一些协议来解决。

### java内存模型
1、主内存与工作内存
java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中去除变量这样的底层细节。变量指实例字段、静态字段和构成数组对象的元素，不包括局部变量和方法参数，因为后者是线程私有的，不被共享。
所有的变量都存储在主内存。
每条线程都有自己的工作内存，工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行。

2、内存间交互
虚拟机实现主内存和工作内存之间的交互操作都是原子的，不可再分的。

3、volatile变量
当一个变量定义为volatile之后，保证了此变量对所有线程的可见性。“可见性”是指当一条线程修改了这个变量的值，新值对于其它线程来说可以立即得知。
volatile变量也存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况。
java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的。

4、有序性
在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。