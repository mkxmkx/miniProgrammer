### 1、Serial收集器
“单线程”， 仅使用一个CPU或一条线程去完成垃圾收集工作。在进行垃圾收集时，必须暂停其它所有的工作线程。
Serial收集器由于没有线程交互的开销，专心做垃圾收集，获得最高的单线程收集效率。
可与CMS收集器配合工作。（CMS收集器：并发收集器，实现垃圾回收线程和用户线程同时工作）

### 2、ParNew收集器
Serial收集器的多线程版本。除使用多条线程进行垃圾回收之外，其余所有控制参数、收集算法、对象分配策略、回收策略都与Serial一样。
存在线程交互的开销。
ParNew收集器可与CMS收集器配合工作。

### 3、Parallel Scavenge收集器
目标是达到可控制的吞吐量。吞吐量优先。吞吐量是CPU用于运行用户代码的时间与CPU总消耗时间的比值。
高吞吐量则可以高效利用CPU时间，尽快完成程序的运算任务。

### 4、Serial Old收集器
Serial收集器的老年代版本。单线程，“标记-整理”算法

### 5、Parallel Old收集器
Parallel Scavenge收集器老年代版本。多线程，“标记-整理”算法
### 6、CMS收集器
以获取最短回收停顿时间为目标的收集器。
分为四个步骤：
#### （1）初始标记
只是标记一下GC Roots能直接关联到的对象。需要暂停所有线程。
#### （2）并发标记
进行GC Roots Tracing的过程。需要暂停所有线程。（耗时较长）
#### （3）重新标记
修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。
时间比初始标记长，比并发标记时间短的多。
#### （4）并发清除
耗时较长。基于“标记-清除”算法实现的收集器