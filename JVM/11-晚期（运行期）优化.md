## java虚拟机——晚期（运行期）优化
### 1、解释器与编译器
许多商用虚拟机都同时包含解释器与编译器。解释器与编译器两者各有优势。
当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。
在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多代码编译成本地代码之后，可以获得更高的执行效率。
当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以使用编译执行来提高效率。

### 2、热点代码
会被即时编译器编译的“热点代码”有两类：
被多次调用的方法；  被多次执行的循环体。
第一种情况被多次调用的方法，编译器会议整个方法作为编译对象。对于第二种情况被多次执行的循环体，编译器仍会以整个方法作为编译对象。因为**编译发生在方法执行过程之中，成为栈上替换（OSR编译），即方法栈帧还在栈上，方法就被替换了。**

如何判断一段代码是不是热点代码，有“基于采样的热点探测”和 **“基于计数器的热点探测”**两种方法。

**基于采样的方法**是周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那么这个方法就是热点代码。缺点：很难精确地确定一个方法的热度。

**基于计数器的方法**是为每个方法建立一个计数器，统计方法执行次数。
基于计数器的方法使用两类计数器：方法调用计数器和回边计数器。
方法调用计数器：计算相对的执行频率，即一段时间之内被调用的次数。若调用次数不足以提交给即时编译器编译，则调用计数器减少一半，称为调用计数器热度的衰减。
回边计数器，统计一个方法中循环体代码执行的次数（绝对次数）

### 3、逃逸分析
逃逸分析并不是直接优化代码的手段，而是为其他优化手段提供依据的分析技术。
逃逸分析的基本行为就是**分析对象动态作用域**。当一个对象在方法中被定义之后，他可能被外部方法所引用，例如作为调用参数传递到其它方法中，成为方法逃逸。或者有可能被外部线程访问到，例如赋值给类变量，成为线程逃逸。

**如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高校的优化。**
如：**栈上分配**：java堆中对象对各个线程是共享的，垃圾收集系统在回收对象整理内存的时候是浪费时间的。如果确定对象不会逃逸，那大量对象会随着方法的结束而自动销毁，垃圾收集系统的压力会小很多。
**同步消除：**线程同步本身是一个相对耗时的过程。如果逃逸分析确定对象不会逃逸出线程，就可以不用采用同步措施。
**标亮替换**：将一个java对象拆散，将其使用到的成员变量回复原始类型来访问就是标量替换。标量替换为后序进一步的优化手段创造条件。